#include <gmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

char * getPrimeFromFile(const char * safePrimeFile);
char * getSeedFromFile (const char * randomSeedFile);

//Generate can either 
void generate (const mpz_t primeString, const mpz_t seedString, mpz_t output, int rightValue);

void psfunc(mpz_t prime, mpz_t seed, mpz_t output, mpz_t key);
void runFeistel(char * primeString, char * seedString);

size_t primeLen = 0;
const int rounds = 3;

mpz_t generatorState;

int main(int argc, const char *argv[]){
	printf("Number of arguments: %d\n", argc-1);
	if (argc < 4){
		printf("Program expects three arguments, <file containing prime group> <file containing random seed / key> <file for output>\n");
		printf("Prime and random key should both be in hex, prime file is generated by ./safePrimeGen");
		printf("Example: ./feistel prime.txt random.txt out.txt\n");
		printf("Quitting\n\n");
		exit(1);
	}
	
	const char * safePrimeFile = argv[1];
	const char * randomSeedFile = argv[2];
	const char * outputFile = argv[4];
	
	printf("File for primes: %s\n", safePrimeFile);
	printf("File for random input: %s\n", randomSeedFile);
	printf("File for output: %s\n", outputFile);
	
	char * primeString = getPrimeFromFile(safePrimeFile);
	char * seedString = getSeedFromFile(randomSeedFile);
	
	printf("primeString: [%s]\n", primeString);
	printf("seedString: [%s]\n", seedString);
	
	runFeistel(primeString, seedString); 
	
	printf("All processing complete\n");
	return 0;
}



void seedGenerator(const char * seed){
	mpz_init_set_str(generatorState, seed, 16);
}

void getBits(mpz_t result){
	mpz_t out;
	return out;
}



//see 258
void generate (const mpz_t m, const mpz_t x, mpz_t output, int rightValue){
	mpz_init_set(output, x);
	
	mpz_t g; //In safe prime groups, g can be the generator.
	mpz_init_set_str(g, "2", 10);
	
	const size_t EXPANSION = primeLen;
	char hc_bits [EXPANSION +1]; //Store as an array of 0 and 1 chars at first.

	mpz_t half_point;
	mpz_init(half_point);
	mpz_t two;
	mpz_init_set_str(two, "2", 10);
	mpz_sub_ui (half_point, m, 1); //Subtract 1 from modulus
	mpz_divexact (half_point, half_point, two); //Divide in half exactly
	
	for(int i = 0; i< EXPANSION; ++i){
		//hardcore(y) = 1 if y < (p-1)/2, 0 if y >= (p-1)/2, where y = f<p,g>(x)
		int comparison = mpz_cmp(output, half_point);
		
		if (comparison < 0){
			hc_bits[i] = '0';
		} else {
			hc_bits[i] = '1';
		}
		
		mpz_powm (output, g, output, m);
	}
	
	hc_bits[EXPANSION] = '\0';
	
	if (rightValue){
		mpz_init_set_str(output, hc_bits, 2);
	}
}



//See page 211
void runFeistel(char * primeString, char * seedString){
	seedGenerator(seedString);
	
	//~ mpz_t output;
//~ 
//~ 
	//~ mpz_init(output);
//~ 
	//~ mpz_t prime, seed, key;
	//~ mpz_init_set_str(prime, primeString, 16);
	//~ mpz_init_set_str(seed, seedString, 16);
	//~ //mpz_init_set_str(key, keyString, 16);
	//~ 
	//~ //Feistel Network implementation 
	//~ //The seed for the left and right parts of the feistel network is psfuncs L and R output
//~ 
	//~ //Initialize stuff
	//~ mpz_t l[rounds+1], r[rounds+1], funcOut[rounds+1], keySchedule[+1];
	//~ for(int i = 0; i <= rounds; i++){
		//~ mpz_init(l[i]);
		//~ mpz_init(r[i]);
		//~ mpz_init(funcOut[i]);
		//~ mpz_init(keySchedule[i]);
	//~ }
//~ 
	//~ generate(prime, seed, l[0], 0);
	//~ generate(prime, seed, r[0], 1);
//~ 
	//~ printf("Key schedule:\n");
	//~ mpz_init_set(keySchedule[0], key);
	//~ for(int i = 0; i < rounds; i++){
		//~ generate(prime, keySchedule[i], keySchedule[i+1], 1);
		//~ gmp_printf("Key %d: %Zx\n",i+1, keySchedule[i+1]);
	//~ }
	//~ printf("\n");
//~ 
	//~ //Feistel rounds v2
	//~ for(int i = 1; i <= rounds; i++){
		//~ mpz_init_set(l[i], r[i-1]);
		//~ psfunc(prime, r[i-1], funcOut[i], keySchedule[i]);
		//~ mpz_xor(r[i], l[i-1], funcOut[i]);
	//~ }
//~ 
	//~ //TODO: Concat these two numbers PROPERLY for the new psudorandom number. 
	//~ gmp_printf("Psuedo Random Number: %Zx", l[3]);
	//~ gmp_printf("%Zx\n", r[3]);
//~ 
	//~ 
	//~ free (primeString);
	//~ free (seedString);
	//~ gmp_printf ("Final output value: %Zx\n", output);
	
}

void psfunc(mpz_t prime, mpz_t seed, mpz_t output, mpz_t key){

	clock_t start = clock();
	//Timing how long it takes to run a PRF on this implementation
	for(int i = 0; i<primeLen; i++){

		if(mpz_tstbit(key, primeLen-1-i)){
			//printf("1");
			generate(prime, seed, output, 1);
			//gmp_printf ("Output1 sub %d: %Zx\n", i, output);
		} else {
			//printf("0");
			generate(prime, seed, output, 0);
			//gmp_printf ("Output0 sub %d: %Zx\n", i, output);
		}

		mpz_init_set(seed, output);
	}
	
	printf("Time taken %ld milliseconds\n", (clock() - start) * 1000 / CLOCKS_PER_SEC);
}


void genKeySche(mpz_t schedule[], int rounds){


}


char * getPrimeFromFile (const char * safePrimeFile){
	printf("Reading %s\n",safePrimeFile);
	FILE * in = fopen(safePrimeFile, "r");

	if (in == NULL) {
		fprintf(stderr, "Can't open primes file %s, quitting.\n", safePrimeFile);
		exit(1);
	}
	
	char * primeLengthLine = NULL;
	size_t primeLength;
	
	size_t maxBytes = 64;
	if (getline (&primeLengthLine, &maxBytes, in) != -1){
		
		unsigned int uiPrimeLen;
		
		if (sscanf(primeLengthLine, "%d", &uiPrimeLen) ){
			primeLength = (size_t)uiPrimeLen;
			
			primeLen = primeLength;
		} else {
			printf("No num on line\n");
			exit (1);
		}
		
	} else {
		printf ("invalid file");
		exit (1);
	}
	
	char * primeHex = NULL;
	
	ssize_t lineLen = 0;
	if (lineLen = getline (&primeHex, &primeLength, in) != -1) {
		size_t len = strlen(primeHex) -1;
		if (primeHex[len] == '\n'){
			primeHex [len] = '\0';  //strip the newline.
		}
	} else {
		printf ("invalid file");
		exit(1);
	}
	
	fclose(in);
	
	return primeHex;
}

char * getSeedFromFile (const char * randomSeedFile){
	printf("Reading %s\n",randomSeedFile);
	FILE * in = fopen(randomSeedFile, "r");

	if (in == NULL) {
		fprintf(stderr, "Can't open seed file %s, quitting.\n", randomSeedFile);
		exit(1);
	}
	
	char * seed = NULL;
	
	ssize_t lineLen = 0;
	long unsigned int maxBytes= 0;
	
	if (lineLen = getline (&seed, &maxBytes, in) != -1) {
		size_t len = strlen(seed) -1;
		if (seed[len] == '\n'){
			seed [len] = '\0';  //strip the newline.
		}
	} else {
		printf ("invalid seed file");
		exit(1);
	}
	
	fclose(in);
	
	return seed;
}
