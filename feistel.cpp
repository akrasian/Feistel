#include <gmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <string>

char * getPrimeFromFile(const char * safePrimeFile);
char * getHexStringFromFile (const char * randomSeedFile);

//Generate can either 
void seedGenerator(const char * seed, const char * prime);
void generate(mpz_t result);
void generateKeySchedule();
char * feistel(const char * plaintext);

void runFeistel();

//Specifies MINIMUM length of prime, specified in given prime file in bits..
//If the file says the prime is 128 bits long, it will in fact be a bit longer to fit the next prime.
size_t primeLen = 0;

const int ROUNDS = 3;
//~ const int ROUNDS = 100;

mpz_t generatorState;
mpz_t groupPrime;
mpz_t groupGenerator;
mpz_t halfPoint;
mpz_t keySchedule [ROUNDS];

int main(int argc, const char *argv[]){
	printf("Number of arguments: %d\n", argc-1);
	if (argc < 5){
		printf("Program expects four arguments, <file containing prime group> <file containing random seed / key> <file containing plaintext hex> <file for output>\n");
		printf("Prime and random key should both be in hex, prime file is generated by ./safePrimeGen");
		printf("Example: ./feistel prime.txt random.txt out.txt\n");
		printf("Quitting\n\n");
		exit(1);
	}
	
	const char * safePrimeFile = argv[1];
	const char * randomSeedFile = argv[2];
	const char * plaintextFile = argv[3];
	const char * outputFile = argv[4];
	
	printf("File for primes       : %s\n", safePrimeFile);
	printf("File for random input : %s\n", randomSeedFile);
	printf("File for output       : %s\n", outputFile);
	
	char * primeString = getPrimeFromFile(safePrimeFile);
	char * seedString = getHexStringFromFile(randomSeedFile);
	char * plaintext = getHexStringFromFile(plaintextFile);
	
	printf("Prime for Group       : [%s]\n", primeString);
	printf("seedString            : [%s]\n", seedString);
	
	seedGenerator(primeString, seedString);
	generateKeySchedule();
	
	printf("Plaintext             : [%s]\n", plaintext);
	
	int plaintextBits =  strlen(plaintext)*4;
	if (plaintextBits != 2*primeLen){
		fprintf(stderr, "Error - plaintext not twice length of prime");
		return 1;
	}
	
	feistel(plaintext);
	
	
	
	printf("All processing complete\n");
	return 0;
}

//Uses PRNG to generate round keys from the key
void generateKeySchedule(){
	for (int i = 0; i< ROUNDS; ++i){
		generate(keySchedule[i]);
	}
}

void seedGenerator(const char * seed, const char * prime){
	mpz_init_set_str(generatorState, seed, 16);
	mpz_init_set_str(groupPrime, prime, 16);
	
	//halfPoint = (prime - 1)/2
	mpz_init(halfPoint);
	mpz_t two;
	mpz_init_set_str(two, "2", 10);
	mpz_sub_ui (halfPoint, groupPrime, 1); //Subtract 1 from modulus
	mpz_divexact (halfPoint, halfPoint, two); //Divide in half exactly
	
	mpz_set (groupGenerator, two); //In safe prime groups, using two as a generator is safe.
}

//see 258
void generate(mpz_t result){
	const size_t EXPANSION = primeLen;
	char hc_bits [EXPANSION +1]; //Store as an array of 0 and 1 chars at first.
	
	for(int i = 0; i< EXPANSION; ++i){
		//hardcore(y) = 1 if y < (p-1)/2, 0 if y >= (p-1)/2, where y = f<p,g>(x)
		int comparison = mpz_cmp(generatorState, halfPoint);
		
		if (comparison < 0){
			hc_bits[i] = '0';
		} else {
			hc_bits[i] = '1';
		}
		
		//state = generator^state mod groupPrime
		mpz_powm (generatorState, groupGenerator, generatorState, groupPrime);
	}
	
	//Terminal array string.
	hc_bits[EXPANSION] = '\0';
	mpz_init_set_str(result, hc_bits, 2);
}

//See page 265
void keyedPRF(mpz_t output, mpz_t key, mpz_t input){
	mpz_init_set(output, input);
	
	for(int i = 0; i<primeLen; i++){
		if(mpz_tstbit(key, i)){
			printf("1");
			//~ generate(prime, seed, output, 1);
			//gmp_printf ("Output1 sub %d: %Zx\n", i, output);
		} else {
			printf("0");
			//~ generate(prime, seed, output, 0);
			//gmp_printf ("Output0 sub %d: %Zx\n", i, output);
		}

		//~ mpz_init_set(seed, output);
	}
}

//See page 211
//output and input should be 256 bits when seeds are 128 bits.
char * feistel(const char * plaintext){
	char leftString [primeLen+1];
	char rightString [primeLen+1];
	
	int fragmentSize = primeLen / 4;
	
	//Cut input in half:
	strncpy(leftString, plaintext, fragmentSize);
	leftString[fragmentSize] = '\0';
	
	strncpy(rightString, plaintext+fragmentSize, fragmentSize);
	rightString[fragmentSize] = '\0';
	
	printf("Left String : [%s]\n", leftString);
	printf("Right String: [%s]\n", rightString);
	
	mpz_t left, right;
	mpz_init_set_str(left, leftString, 16);
	mpz_init_set_str(right, rightString, 16);
	
	gmp_printf("Left MPZ    : [%Zx] \n", left);
	gmp_printf("Right MPZ   : [%Zx] \n", right);
	
	for (int round = 0; round < ROUNDS; ++round){
		gmp_printf("Round %d key : [%Zx] \n", round, keySchedule[round]);
		
		//Copy right for later.
		mpz_t temp;
		//~ mpz_init(temp);
		mpz_init_set(temp, right);
		
		//Right = prev left xor F(prev right)
		keyedPRF(right, keySchedule[round], right);
		mpz_xor(right, left, right);
		
		//Left = Right(n-1)
		mpz_set(left, temp);
	}
	char * x;
	return x;
}

void runFeistel(){
	
}

char * getPrimeFromFile (const char * safePrimeFile){
	printf("Reading %s\n",safePrimeFile);
	FILE * in = fopen(safePrimeFile, "r");

	if (in == NULL) {
		fprintf(stderr, "Can't open primes file %s, quitting.\n", safePrimeFile);
		exit(1);
	}
	
	char * primeLengthLine = NULL;
	size_t primeLength;
	
	size_t maxBytes = 64;
	if (getline (&primeLengthLine, &maxBytes, in) != -1){
		
		unsigned int uiPrimeLen;
		
		if (sscanf(primeLengthLine, "%d", &uiPrimeLen) ){
			primeLength = (size_t)uiPrimeLen;
			
			primeLen = primeLength;
		} else {
			printf("No num on line\n");
			exit (1);
		}
		
	} else {
		printf ("invalid file");
		exit (1);
	}
	
	char * primeHex = NULL;
	
	ssize_t lineLen = 0;
	if (lineLen = getline (&primeHex, &primeLength, in) != -1) {
		size_t len = strlen(primeHex) -1;
		if (primeHex[len] == '\n'){
			primeHex [len] = '\0';  //strip the newline.
		}
	} else {
		printf ("invalid file");
		exit(1);
	}
	
	fclose(in);
	
	return primeHex;
}

char * getHexStringFromFile (const char * randomSeedFile){
	printf("Reading %s\n",randomSeedFile);
	FILE * in = fopen(randomSeedFile, "r");

	if (in == NULL) {
		fprintf(stderr, "Can't open seed file %s, quitting.\n", randomSeedFile);
		exit(1);
	}
	
	char * seed = NULL;
	
	ssize_t lineLen = 0;
	long unsigned int maxBytes= 0;
	
	if (lineLen = getline (&seed, &maxBytes, in) != -1) {
		size_t len = strlen(seed) -1;
		if (seed[len] == '\n'){
			seed [len] = '\0';  //strip the newline.
		}
	} else {
		printf ("invalid seed file");
		exit(1);
	}
	
	fclose(in);
	
	return seed;
}
