#include <gmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <string>

const int ROUNDS = 3; //Same as in DES.

char * getPrimeFromFile(const char * safePrimeFile);
char * getHexStringFromFile (const char * randomSeedFile);

//Generate can either 
void initGenerator(const char *primeString);
void seedGeneratorForKeys(const char *seedString);

void generateLeft(mpz_t result); //returns from hc bits
void generateRight(mpz_t result); //returns from state.
void generateKeySchedule();
void feistel(char * result, const char * plaintext);

//Specifies MINIMUM length of prime, specified in given prime file in bits..
//If the file says the prime is 128 bits long, it will in fact be a bit longer to fit the next prime.
size_t primeLen = 0;

//The key schedule used in all iterations for this feistel network.
mpz_t keySchedule [ROUNDS];

//State for the RNG.
mpz_t generatorState;
mpz_t groupPrime;
mpz_t groupGenerator;
mpz_t halfPoint;

int main(int argc, const char *argv[]){
	printf("Number of arguments: %d\n", argc-1);
	if (argc < 5){
		printf("Program expects four arguments, <file containing prime group> <file containing random seed / key> <file containing plaintext hex> <file for output>\n");
		printf("Prime and random key should both be in hex, prime file is generated by ./safePrimeGen");
		printf("Example: ./feistel prime.txt random.txt out.txt\n");
		printf("Quitting\n\n");
		exit(1);
	}
	
	const char * safePrimeFile = argv[1];
	const char * randomSeedFile = argv[2];
	const char * plaintextFile = argv[3];
	const char * outputFile = argv[4];
	
	printf("File for primes       : %s\n", safePrimeFile);
	printf("File for random input : %s\n", randomSeedFile);
	printf("File for output       : %s\n", outputFile);
	
	char * primeString = getPrimeFromFile(safePrimeFile);
	char * seedString = getHexStringFromFile(randomSeedFile);
	char * plaintext = getHexStringFromFile(plaintextFile);
	int plaintextLength = strlen(plaintext);

	printf("Prime for Group       : [%s]\n", primeString);
	printf("seedString            : [%s]\n", seedString);
	
	initGenerator(primeString);
	seedGeneratorForKeys(seedString);
	generateKeySchedule();
	
	printf("Plaintext             : [%s]\n", plaintext);
	
	int plaintextBits = plaintextLength*4;
	if (plaintextBits != 2*primeLen){
		fprintf(stderr, "Error - plaintext not twice length of prime");
		return 1;
	}
	
	//Initialize a buffer.
	char result [plaintextLength+ 1];
	
	feistel(result, plaintext);
	//~ printf("Result: ac8b0e8e12c43ab%s\n", result);
	printf("Result:               : [%s]\n", result);
	
	printf("All processing complete\n");
	return 0;
}

//Uses PRNG to generate round keys from the key
void generateKeySchedule(){
	for (int i = 0; i< ROUNDS; ++i){
		generateRight(keySchedule[i]);
	}
}

//initialize groupPrime, halfPoint, groupGenerator
void initGenerator(const char * prime){
	mpz_init_set_str(groupPrime, prime, 16);
	
	//halfPoint = (prime - 1)/2
	mpz_init(halfPoint);
	mpz_t two;
	mpz_init_set_str(two, "2", 10);
	mpz_sub_ui (halfPoint, groupPrime, 1); //Subtract 1 from modulus
	mpz_divexact (halfPoint, halfPoint, two); //Divide in half exactly
	
	mpz_set (groupGenerator, two); //In safe prime groups, using two as a generator is safe.
}

void seedGeneratorForKeys(const char * seed){
	mpz_init_set_str(generatorState, seed, 16);
}

void seedGeneratorWithKey(mpz_t key){
	mpz_set(generatorState, key);
}

//see 258 for expansion of bits
//This always returns the *right side* of the generated 2n bit string, so the state is not compromised..
void generateRight(mpz_t result){
	const size_t EXPANSION = primeLen;
	char hc_bits [EXPANSION +1]; //Store as an array of 0 and 1 chars at first.
	
	for(int i = 0; i< EXPANSION; ++i){
		//hardcore(y) = 1 if y < (p-1)/2, 0 if y >= (p-1)/2, where y = f<p,g>(x)
		int comparison = mpz_cmp(generatorState, halfPoint);
		
		if (comparison < 0){
			hc_bits[i] = '0';
		} else {
			hc_bits[i] = '1';
		}
		
		//state = generator^state mod groupPrime
		mpz_powm (generatorState, groupGenerator, generatorState, groupPrime);
	}
	
	//Terminal array string.
	hc_bits[EXPANSION] = '\0';
	mpz_set_str(result, hc_bits, 2);
}

//Returns the state directly, so can't be used over and over for independent results.
void generateLeft(mpz_t result){
	const size_t EXPANSION = primeLen;
	
	for(int i = 0; i< EXPANSION; ++i){
		mpz_powm (generatorState, groupGenerator, generatorState, groupPrime);
	}
	
	mpz_set(result, generatorState);
}

//See page 265
//Uses the key as a sequence of bits dictating whether to take the left or right gen output each time.
void keyedPRF(mpz_t output, mpz_t key, mpz_t input){
	mpz_set(output, input);
	
	for(int i = 0; i<primeLen; i++){
		seedGeneratorWithKey(output);
		
		if(mpz_tstbit(key, i)){
			//~ printf("1");
			generateRight(output);
		} else {
			generateLeft(output);
		}
	}
}

//See page 211
//output and input should be 256 bits when seeds are 128 bits.
void feistel(char * result, const char * plaintext){
	//Global var: keySchedule - will be used the same in every run of the feistel network.
	int fragmentSize = primeLen / 4;
	
	char leftString [fragmentSize+1];
	char rightString [fragmentSize+1];
	
	//Cut input in half:
	strncpy(leftString, plaintext, fragmentSize);
	leftString[fragmentSize] = '\0';
	
	strncpy(rightString, plaintext+fragmentSize, fragmentSize);
	rightString[fragmentSize] = '\0';
	
	mpz_t left, right, temp;
	mpz_init(temp);
	mpz_init_set_str(left, leftString, 16);
	mpz_init_set_str(right, rightString, 16);
	
	for (int round = 0; round < ROUNDS; ++round){
		mpz_set(temp, right);
		mpz_t roundKey;
		keyedPRF(right, keySchedule[round], right);
		mpz_xor(right, left, right);
		mpz_set(left, temp);
	}
	
	gmp_sprintf(leftString, "%Zx", left);
	gmp_sprintf(rightString, "%Zx", right);
	
	//Ensure result is empty before adding characters.
	result[0] = '\0';
	strncat (result, leftString, fragmentSize+1);
	strncat (result + fragmentSize, rightString, fragmentSize+1);
}

char * getPrimeFromFile (const char * safePrimeFile){
	printf("Reading %s\n",safePrimeFile);
	FILE * in = fopen(safePrimeFile, "r");

	if (in == NULL) {
		fprintf(stderr, "Can't open primes file %s, quitting.\n", safePrimeFile);
		exit(1);
	}
	
	char * primeLengthLine = NULL;
	size_t primeLength;
	
	size_t maxBytes = 64;
	if (getline (&primeLengthLine, &maxBytes, in) != -1){
		
		unsigned int uiPrimeLen;
		
		if (sscanf(primeLengthLine, "%d", &uiPrimeLen) ){
			primeLength = (size_t)uiPrimeLen;
			
			primeLen = primeLength;
		} else {
			printf("No num on line\n");
			exit (1);
		}
		
	} else {
		printf ("invalid file");
		exit (1);
	}
	
	char * primeHex = NULL;
	
	ssize_t lineLen = 0;
	if (lineLen = getline (&primeHex, &primeLength, in) != -1) {
		size_t len = strlen(primeHex) -1;
		if (primeHex[len] == '\n'){
			primeHex [len] = '\0';  //strip the newline.
		}
	} else {
		printf ("invalid file");
		exit(1);
	}
	
	fclose(in);
	
	return primeHex;
}

char * getHexStringFromFile (const char * randomSeedFile){
	printf("Reading %s\n",randomSeedFile);
	FILE * in = fopen(randomSeedFile, "r");

	if (in == NULL) {
		fprintf(stderr, "Can't open seed file %s, quitting.\n", randomSeedFile);
		exit(1);
	}
	
	char * seed = NULL;
	
	ssize_t lineLen = 0;
	long unsigned int maxBytes= 0;
	
	if (lineLen = getline (&seed, &maxBytes, in) != -1) {
		size_t len = strlen(seed) -1;
		if (seed[len] == '\n'){
			seed [len] = '\0';  //strip the newline.
		}
	} else {
		printf ("invalid seed file");
		exit(1);
	}
	
	fclose(in);
	
	return seed;
}
